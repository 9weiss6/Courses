### Целочисленные типы в C++

Все целочисленные типы (кроме char) являются знаковыми. Беззнаковые версии типов определяется с ключевым словом unsigned, например: unsigned short int, unsigned int или unsigned long int. Для симметрии в языке предусмотрено явное указание того, что тип является знаковым — ключевое слово signed (используется редко).


Более того, C++ допускает использование следующих сокращений:

* unsigned вместо unsigned int,
* short вместо short int,
* long вместо long int.

Тип char в языке C++ является особенным: стандарт не оговаривает является ли тип char знаковым или беззнаковым — это зависит от компилятора. Если вам нужна именно беззнаковая версия используйте unsigned char явно, если же вам нужна знаковая используйте signed char. При этом все три типа (char, unsigned char, signed char) являются тремя различными типами.

**Операции инкремента и декремента**
```C++
int a = 10; // a = 10
int b = ++a; // префиксный инкремент возвращает новое значение => b = 11 и a = 11
int c = a++; // постфиксный инкремент возвращает старое значение => с = 11 и a = 12
```

### Преобразование встроенных типов в операторах

Выражениям так же как и значениям в C++ приписывается некоторые типы. Например, если a и b — это переменные типа int, то выражения (a + b), (a - b), (a * b) и (a / b) тоже будут иметь тип int. 

Важно всегда понимать, какой тип у выражения, которое вы написали в программе. Давайте проиллюстрируем это на следующем примере:
```C++
int a = 20;
int b = 50;
double d = a / b;  // d = 0, оба аргумента целочисленные, а значит деление целочисленное 
```
Как исправить этот код, чтобы получить вещественное значение в переменной d? 

Для этого хотя бы один из аргументов оператора деления должен иметь типа double. Этого можно добиться при помощи уже известного нам оператора приведения типов:
```C++
double d = (double)a / b;  // d = 0.4
```
Почему это сработало? Дело в том, что операторы для встроенных типов C++ **всегда** работают с **одинаковыми типами аргументов**. Если аргументы имеют разные типы, то происходит преобразование типов (promotion).

**Правило преобразования встроенных типов в операторах**

Рассмотрим выражение (a + b), где вместо '+' может стоять любой другой подходящий оператор
    
* Если один из аргументов имеет числовой тип с плавающей точкой, то второй аргумент приводится к этому типу (например, при сложении double и int значение типа int приводится к double). 

* Если оба аргумента имеют числовой тип с плавающей точкой, то выбирается наибольший из этих типов (например, при сложении double и float значение типа float приводится к double)

* Если оба аргумента целочисленные, но их типы меньше int, то оба аргумента приводятся к типу int (например, при сложении двух значений типа char они оба сначала приводятся к int).

* Если оба аргумента целочисленные, то аргумент с меньшим типом приводится к типу второго аргумента (например, при сложении long и int значение типа int приводится к long).

* Если оба аргумента целочисленные и имеют тип одного размера, то предпочтение отдаётся беззнаковому типу (например, при сложении int и unsigned int значение типа int приводится к unsigned int).

**Несколько важных следствий**

* Следите за тем, какие типы участвуют в выражении, от этого может зависеть его значение.

* Не стоит использовать целочисленные типы меньше int в арифметических выражениях, они всё равно будут приведены к int.

* **Не стоит смешивать unsigned и signed типы** в одном выражении, это может привести к неприятным последствиям.

Для иллюстрации последнего следствия давайте рассмотрим следующий пример:
``` C++
unsigned from = 100;
unsigned to = 0;
for (int i = from; i >= to; --i) {  ....  }
```
Сколько итераций сделает этот цикл? На самом деле этот цикл — бесконечный: в условии цикла проверяется i >= to, где тип i — int, а тип to — unsigned int. Так как операторы всегда применяются к одинаковым встроенным типам, то в данном случае значение переменной i (в соответствии с правилом 5) будет преобразовано к unsigned int, а значения этого типа **всегда** неотрицательны, т.е. >= 0. Другими словами, когда пременная i станет равной -1, то в условии будет проверяться (unsigned)-1 >= 0, где  (unsigned)-1 = UINT_MAX (UINT_MAX — максимальное значение, которое может принимать переменная типа unsigned int).

### Преобразование встроенных типов в операторах

Выражениям так же как и значениям в C++ приписывается некоторые типы. Например, если a и b — это переменные типа int, то выражения (a + b), (a - b), (a * b) и (a / b) тоже будут иметь тип int. 

Важно всегда понимать, какой тип у выражения, которое вы написали в программе. Давайте проиллюстрируем это на следующем примере:
``` C++
int a = 20;
int b = 50;
double d = a / b;  // d = 0, оба аргумента целочисленные, а значит деление целочисленное 
```
Как исправить этот код, чтобы получить вещественное значение в переменной d? 

Для этого хотя бы один из аргументов оператора деления должен иметь типа double. Этого можно добиться при помощи уже известного нам оператора приведения типов:
```C++
double d = (double)a / b;  // d = 0.4
```
Почему это сработало? Дело в том, что операторы для встроенных типов C++ **всегда** работают с **одинаковыми типами аргументов**. Если аргументы имеют разные типы, то происходит преобразование типов (promotion).

#### Правило преобразования встроенных типов в операторах

Рассмотрим выражение (a + b), где вместо '+' может стоять любой другой подходящий оператор.
* Если один из аргументов имеет числовой тип с плавающей точкой, то второй аргумент приводится к этому типу (например, при сложении double и int значение типа int приводится к double). 
* Если оба аргумента имеют числовой тип с плавающей точкой, то выбирается наибольший из этих типов (например, при сложении double и float значение типа float приводится к double). 
* Если оба аргумента целочисленные, но их типы меньше int, то оба аргумента приводятся к типу int (например, при сложении двух значений типа char они оба сначала приводятся к int).
* Если оба аргумента целочисленные, то аргумент с меньшим типом приводится к типу второго аргумента (например, при сложении long и int значение типа int приводится к long).
* Если оба аргумента целочисленные и имеют тип одного размера, то предпочтение отдаётся беззнаковому типу (например, при сложении int и unsigned int значение типа int приводится к unsigned int).

#### Несколько важных следствий
* Следите за тем, какие типы участвуют в выражении, от этого может зависеть его значение.
* Не стоит использовать целочисленные типы меньше int в арифметических выражениях, они всё равно будут приведены к int.
* **Не стоит смешивать unsigned и signed типы** в одном выражении, это может привести к неприятным последствиям.

Для иллюстрации последнего следствия давайте рассмотрим следующий пример:
``` C++
unsigned from = 100;
unsigned to = 0;
for (int i = from; i >= to; --i) {  ....  }
```
Сколько итераций сделает этот цикл? На самом деле этот цикл — бесконечный: в условии цикла проверяется **i >= to, где тип i — int, а тип to — unsigned int**. Так как операторы всегда применяются к одинаковым встроенным типам, то в данном случае значение переменной i (в соответствии с правилом 5) будет преобразовано к unsigned int, а значения этого типа всегда неотрицательны, т.е. >= 0. Другими словами, когда пременная i станет равной -1, то в условии будет проверяться **(unsigned)-1 >= 0, где  (unsigned)-1 = UINT_MAX** (UINT_MAX — максимальное значение, которое может принимать переменная типа unsigned int).

### Цикл do-while

В С++ существует вариация цикла while, которая называется do-while. В отличие от обычного while в do-while условие проверяется не до, а после итерации. Т.е. такой цикл всегда имеет хотя бы одну итерацию.

Давайте сравним обычный while:
``` C++
int i = 10;
int sum = 0;
while (i < 10) {
    sum += i;
}
// sum = 0
```
И do-while: 
``` C++
int i = 10;
int sum = 0;
do {
    sum += i;
} while(i < 10);
// sum = 10
```
Как видите, в случае с do-while мы добавили 10 к переменной sum, а в обычном while — нет.

Иногда цикл do-while используется в макросах (см. следующий урок) для того, чтобы объединить несколько инструкций в одну. Действительно, если мы обернём инструкции в do-while c ложным условием, то это будет удобной синтаксической конструкцией, все инструкции которой выполнятся ровно один раз.
``` C++
do { /* code */ } while(false); // тело цикла выполнится ровно один раз
```

### Управление циклами

В предыдущем степе упомянут оператор break, который используется для выхода из цикла. Рассмотрим его действие на следующем примере.
``` C++
int a = 323;
int b = 2;
while ( b <= a ) { 
    if ( a % b == 0 )
        break; // выйти из цикла
    b = b + 1;
}
```
После выполнения этого цикла мы найдём минимальное целочисленное b > 1 такое, что а делится на b, т.е. найдём наименьший простой делитель числа a. В данном случае b будет равен 17, т.к. 323 = 17 × 19.

Ещё один оператор, который можно использовать с циклами — это оператор **continue**. Оператор **continue** прерывает текущую итерацию цикла и переходит к следующей. Например, можно посчитать сумму всех чисел от 1 до 100, которые не делятся на 17 или 19, следующим образом.
```C++
int sum = 0;
for ( int i = 1; i <= 100; ++i ) {
    if ( (i % 17 == 0) || (i % 19 == 0) )
        continue; // перейти к следующей итерации
    sum += i;
}
```