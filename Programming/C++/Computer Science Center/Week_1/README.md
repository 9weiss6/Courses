
## Характеристики языка C++:

### Характеристики C++:

* сложный,
* мультипарадигмальный,
* эффективный,
* низкоуровневый,
* компилируемый,
* статически типизированный.

### Сложность:

* Описание стандарта занимает более 1300 страниц текста.
* Нет никакой возможности рассказать “весь C++” в рамках
одного, пусть даже очень большого курса.
* В C++ программисту позволено очень многое, и это влeчёт
за собой большую ответственность.
* На плечи программиста ложится много дополнительной
работы:
    - проверка корректности данных,
    - управление памятью,
    - обработка низкоуровневых ошибок.

### Мультипарадигмальный:

На C++ можно писать программы в рамках нескольких
парадигм программирования:
* процедурное программирование
(код “в стиле C”),
* объектно-ориентированное программирование
(классы, наследование, виртуальные функции, . . . ).
* обобщённое программирование
(шаблоны функций и классов),
* функциональное программирование
(функторы, безымянные функции, замыкания),
* генеративное программирование
(метапрограммирование на шаблонах).

### Эффективный:

Одна из фундаментальных идей языков C и C++ — отсутствие
неявных накладных расходов, которые присутствуют в других
более высокоуровневых языках программирования.

* Программист сам выбирает уровень абстракции, на
котором писать каждую отдельную часть программы.
* Можно реализовывать критические по производительности
участки программы максимально эффективно.
* Эффективность делает C++ основным языком для
разработки приложений с компьютерной графикой (к
примеру, игры).

### Низкоуровневый:

Язык C++, как и C, позволяет работать напрямую с ресурсами
компьютера.
* Позволяет писать низкоуровневые системные приложения
(например, драйверы операционной системы).
* Неаккуратное обращение с системными ресурсами может
привести к падению программы.
В C++ отсутствует автоматическое управление памятью.
* Позволяет программисту получить полный контроль над
программой.
* Необходимость заботиться об освобождении памяти.

### Компилируемый:

C++ является компилируемым языком программирования.
Для того, чтобы запустить программу на C++, её нужно сначала
скомпилировать.
Компиляция — преобразование текста программы на языке
программирования в машинный код.
* Нет накладных расходов при исполнении программы.
* При компиляции можно отловить некоторые ошибки.
* Требуется компилировать для каждой платформы
отдельно.

### Статическая типизация: 

C++ является статически типизированным языком.
1. Каждая сущность в программе (переменная, функция и
пр.) имеет свой тип,
2. и этот тип определяется на момент компиляции.
Это нужно для того, чтобы
1. вычислить размер памяти, который будет занимать
каждая переменная в программе,
2. определить, какая функция будет вызываться в каждом
конкретном месте.

Всё это определяется на момент компиляции и “зашивается” в
скомпилированную программу.
В машинном коде никаких типов уже нет — там идёт работа с
последовательностями байт. 

## Компиляция:

#### Что такое компиляция (C++):
 
(Идея) --> (проектирование)--> Архитектура приложения --> (программирование) --> Код на С++ --> (компиляция) --> Машинный код --> (исполнение) --> PC


#### Что такое компиляция (Java):
 
(Идея) --> (проектирование)--> Архитектура приложения --> (программирование) --> Код на Java --> (компиляция) --> Байт код --> (исполнение) --> JavaVirtualMachine <---> PC


#### Что такое интерпретация:
 
(Идея) --> (проектирование)--> Архитектура приложения --> (программирование) --> Код на Perl --> (интерпретация) --> Perl --> (Трансляция команд) --> PC


### Плюсы и минусы компилируемости в машинный код:

#### Плюсы:
* эффективность: программа компилируется и
оптимизируется для конкретного процессора,
* нет необходимости устанавливать сторонние приложения
(такие как интерпретатор или виртуальная машина).

#### Минусы:
* нужно компилировать для каждой платформы,
* сложность внесения изменения в программу — нужно
перекомпилировать заново.

**Важно:** компиляция — преобразование одностороннее, нельзя
восстановить исходный код.

# Введение в синтаксис С:

### Типы данных

* Целочисленные:
    1. char (символьный тип данных)
    2. short int
    3. int
    4. long int
    Могут быть беззнаковыми (**unsigned**).
    * −2n−1 ... (2n−1 − 1) (n — число бит)
    * 0 ... (2n − 1) для unsigned
* Числа с плавающей точкой:
    1. float, 4 байта, 7 значащих цифр.
    2. double, 8 байт, 15 значащих цифр.
* Логический тип данных **bool** .
* Пустой тип **void**.

### Литералы

* Целочисленные:
    1. ’a’ — код буквы ’a’, тип **char**,
    2. 42 — все целые числа по умолчанию типа **int**,
    3. 1234567890L — суффикс ’L’ соответствует типу **long**,
    4. 1703U — суффикс ’U’ соответствует типу unsigned **int**,
    5. 2128506UL — соответствует типу unsigned **long**.
* Числа с плавающей точкой:
    1. 3.14 — все числа с точкой по умолчанию типа **double**,
    2. 2.71F — суффикс ’F’ соответствует типу **float**,
    3. 3.0E8 — соответствует 3.0 · 108
* true и false — значения типа bool.
* Строки задаются в двойных кавычках: "Text string".

### Переменные

* При определении переменной указывается её тип. При
определении можно сразу задать начальное значение (инициализация).
```
int i = 10;
short j = 20;
bool b = false ;
unsigned long l = 123123;
double x = 13.5 , y = 3.1415;
float z ;
```
* Нужно всегда инициализировать переменные.
* Нельзя определить переменную пустого типа **void**.

### Операции
* Оператор присваивания: =.
* Арифметические:
    1. бинарные: + - * / %,
    2. унарные: ++ --.
* Логические:
    1. бинарные: && ||,
    2. унарные: !.
* Сравнения: == != > < >= <=.
* Приведения типов: (type).
* Сокращённые версии бинарных операторов: += -= *= /= %=.
```
int i = 10;
i = (20 * 3) % 7;
int k = i ++;
int l = --i ;
bool b = !( k == l );
b = ( a == 0) ||
(1 / a < 1);
double d = 3.1415;
float f = ( int ) d ;
// d = d * (i + k)
d *= i + k ;
```

### Инструкции

* Выполнение состоит из последовательности инструкций.
* Инструкции выполняются одна за другой.
* Порядок вычислений внутри инструкций не определён.
```
/* unspecified behavior */
int i = 10;
i = ( i += 5) + ( i * 4);
```
* Блоки имеют вложенную область видимости:
```
int k = 10;
{
int k = 5 * i ; // не видна за пределами блока
i = ( k += 5) + 5;
}
k = k + 1;
```

### Условные операторы

* Оператор **if**:
```
int d = b * b - 4 * a * c ;
if ( d > 0 ) {
roots = 2;
} else if ( d == 0 ){
roots = 1;
} else {
roots = 0;
}
```
* Тернарный условный оператор:
```
int roots = 0;
if ( d >= 0)
roots = ( d > 0 ) ? 2 : 1;
```

### Циклы

* Цикл **while**:
```
int squares = 0;
int k = 0;
while ( k < 10 ) {
squares += k * k;
k = k + 1;
}
```
* Цикл **for**:
```
for ( int k = 0; k < 10; k = k + 1 ) 
{ squares += k * k; }
```
* Для выхода из цикла используется оператор **break**.

### Функции

* В сигнатуре функции указывается тип возвращаемого
значений и типы параметров.
* Ключевое слово **return** возвращает значение.
```
double square ( double x ) 
{ return x * x ; }
```
* Переменные, определённые внутри функций, — локальные.
* Функция может возвращать **void**.
* Параметры передаются по значению (копируются).
```
void strange ( double x , double y ) 
{ x = y; }
```

### Макросы

* Макросами в C++ называют инструкции препроцессора.
* Препроцессор C++ является самостоятельным языком, работающим с произвольными строками.
* Макросы можно использовать для определения функций:
```
int max1 ( int x , int y ) {
return x > y ? x : y ;
}

# define max2 (x , y ) x > y ? x : y
a = b + max2 (c , d ); // b + c > d ? c : d;
```
* Препроцессор “не знает” про синтаксис C++.
* Параметры макросов нужно оборачивать в скобки:
```
# define max3 (x , y ) (( x ) > ( y ) ? (x ) : ( y ))
∙ Это не избавляет от всех проблем:
int a = 1;
int b = 1;
int c = max3 (++ a , b );
// c = ((++a) > (b) ? (++a) : (b))
```
* Определять функции через макросы — плохая идея.
* Макросы можно использовать для условной компиляции:
```
# ifdef DEBUG
// дополнительные проверки
# endif
```

### Ввод-вывод

* Будем использовать библиотеку **<iostream>**.
```
# include < iostream >
using namespace std ;
```
* Ввод:
```
int a = 0;
int b = 0;
cin >> a >> b ;
```
* Вывод:
```
cout << " a + b = " << ( a + b ) << endl ;
```

## Простая программа
```
# include < iostream >
using namespace std ;
int main ()
{
int a = 0;
int b = 0;
cout << " Enter a and b : " ;
cin >> a >> b ;
cout << " a + b = " << ( a + b ) << endl ;
return 0;
}
```
